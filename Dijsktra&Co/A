def read_list(n, m):
    adj_list = [[] for _ in range(n)]
    for _ in range(m):
        s, f, w = map(int, input().split())
        adj_list[s].append((f, w))
        adj_list[f].append((s, w))  # если граф неориентированный
    return adj_list

def dijkstra(adj_list, start_node):
    dist = {i: float('inf') for i in range(len(adj_list))}
    dist[start_node] = 0
    res = {}
    while dist:
        min_node = min(dist, key=dist.get)  # находим узел с минимальным dist
        min_dist = dist[min_node]
        res[min_node] = min_dist
        dist.pop(min_node)
        for adj_node, weight in adj_list[min_node]:
            if adj_node in dist and dist[adj_node] > min_dist + weight:
                dist[adj_node] = min_dist + weight
    return res
        
n, m, s, f = map(int, input().split())
adj_list = read_list(n, m)
print(dijkstra(adj_list, s))
'''добавить в функцию дийсктры путь до вершины f(какие рёбра пройдены)'''