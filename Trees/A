class Node:
    def __init__(self, value, left=None, right=None):
        self.v = value
        self.l = left
        self.r = right


class Bin_tree:
    def __init__(self, value):
        self.root = Node(value)

    def _is_bst_helper(self, node, min_val, max_val):
        """
        Рекурсивный помощник для проверки, является ли дерево BST.
        :param node: Текущая вершина.
        :param min_val: Минимальное допустимое значение для текущей вершины.
        :param max_val: Максимальное допустимое значение для текущей вершины.
        :return: True, если дерево является BST, иначе False.
        """
        if node is None:
            return True

        # Проверяем, что значение текущей вершины лежит в допустимом диапазоне
        if not (min_val < node.v < max_val):
            return False

        # Рекурсивно проверяем левое и правое поддеревья
        return (self._is_bst_helper(node.l, min_val, node.v)) and (self._is_bst_helper(node.r, node.v, max_val))

    def is_bst(self):
        """
        Проверяет, является ли дерево BST.
        :return: True, если дерево является BST, иначе False.
        """
        return self._is_bst_helper(self.root, float('-inf'), float('inf'))


n = int(input())
vertices = []
for _ in range(n):
    value, left, right = map(int, input().split())
    vertices.append((value, left, right))

nodes = [Node(value) for value, _, _ in vertices]

# Устанавливаем ссылки на левые и правые поддеревья
for i, (_, left, right) in enumerate(vertices):
    if left != -1:
        nodes[i].l = nodes[left]
    if right != -1:
        nodes[i].r = nodes[right]

# Создаем объект Bin_tree
tree = Bin_tree(nodes[0].v)
tree.root = nodes[0]  # Устанавливаем корень дерева

# Проверка, является ли дерево BST
if tree.is_bst():
    print("YES")
else:
    print("NO")
